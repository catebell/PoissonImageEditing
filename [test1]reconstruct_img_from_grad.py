# -*- coding: utf-8 -*-
"""ReconstructImgByGrad

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1S0Szfw-wFuk51bCP6wmHzeTh_fLF0fgB

https://github.com/PPPW/poisson-image-editing/blob/master/main.py

https://cs.brown.edu/courses/cs129/asgn/proj3_poisson/index.html

https://erkaman.github.io/posts/poisson_blending.html

https://github.com/Erkaman/poisson_blend/blob/master/src/main.cpp
"""

import numpy as np
from PIL import Image
from scipy.sparse import lil_matrix
from scipy.sparse.linalg import spsolve

img = Image.open('imgs/butterfly.jpg')

"""# BLACK AND WHITE"""

img_matrix_L = np.asarray(img.convert('L'), copy=True)

binary_mask = np.ones((img_matrix_L.shape[0],img_matrix_L.shape[1]), dtype=bool)
binary_mask[0,:] = 0
binary_mask[:,0] = 0
binary_mask[-1,:] = 0
binary_mask[:,-1] = 0

# indice dei pixel da ricostruire:

ix = -np.ones((img_matrix_L.shape[0],img_matrix_L.shape[1]), dtype=int)
i = 0

for r in range(img_matrix_L.shape[0]):
  for c in range(img_matrix_L.shape[1]):
      if binary_mask[r,c]:
        ix[r,c] = i
        i=i+1

"""## [DISCARDER] Computation of the image x and y gradient components with Sobel masks:"""

# Gradiente calcolato solo sui pixel interni, con dimensioni ridotte rispetto a immagine di input

img_matrix_L = np.asarray(img.convert('L'), copy=True)

sobel_mask = np.array([[[-1, 0, 1], [-2, 0, 2], [-1, 0, 1]], [[1, 2, 1], [0, 0, 0], [-1, -2, -1]]])

Gx = np.zeros((img_matrix_L.shape[0] - 3 + 1, img_matrix_L.shape[1] - 3 + 1))
Gy = np.zeros((img_matrix_L.shape[0] - 3 + 1, img_matrix_L.shape[1] - 3 + 1))

print(Gx.shape)

for h in range(img_matrix_L.shape[0] -3 +1):
    for w in range(img_matrix_L.shape[1] -3 +1):
        Gx[h,w] = np.sum(img_matrix_L[h : 3 + h, w : 3 + w] * sobel_mask[0])
        Gy[h,w] = np.sum(img_matrix_L[h : 3 + h, w : 3 + w] * sobel_mask[1])

M = np.sqrt(Gx * Gx + Gy * Gy)
img_matrix_L_grad = img_matrix_L.copy()
img_matrix_L_grad[1:-1,1:-1]=M  # M has float values, here they become int

# gradiente calcolato su immagine padded, stessa dimensione dell'input

img_matrix_L = np.asarray(img.convert('L'), copy=True)

padded = np.zeros((img_matrix_L.shape[0]+2,img_matrix_L.shape[1]+2))

padded[1:-1,1:-1] = img_matrix_L.copy()

sobel_mask = np.array([[[-1, 0, 1], [-2, 0, 2], [-1, 0, 1]], [[1, 2, 1], [0, 0, 0], [-1, -2, -1]]])

Gx = np.zeros((img_matrix_L.shape[0], img_matrix_L.shape[1]))
Gy = np.zeros((img_matrix_L.shape[0], img_matrix_L.shape[1]))

for h in range(img_matrix_L.shape[0]):
    for w in range(img_matrix_L.shape[1]):
        Gx[h,w] = np.sum(padded[h : 3 + h, w : 3 + w] * sobel_mask[0])
        Gy[h,w] = np.sum(padded[h : 3 + h, w : 3 + w] * sobel_mask[1])

M = np.sqrt(Gx * Gx + Gy * Gy)
Image.fromarray(M.astype(np.uint8)).show()

#N = (img_matrix_L.shape[0] - 4) * (img_matrix_L.shape[1] - 4)
N = len(binary_mask[binary_mask==1])

"""In 2D:
- Per ricostrire f4 solo gradienti: v5,4 + v5,6
- Per ricostruire f3 anche contorno conosciuto: v3,2 + v3,4 + f2
"""

i = 0
A = lil_matrix((N,N))
b = np.zeros(N)

# r e c per scorrere sulla matrice immagine e sulla maschera
for r in range(0, img_matrix_L.shape[0]):
  for c in range(0, img_matrix_L.shape[1]):

    if binary_mask[r,c] == 0: continue  # non è un pixel da ricostruire

    A[i,i] = 4
    b[i] = Gx[r,c]-Gx[r,c-1] + Gy[r,c]-Gy[r-1,c]
    if binary_mask[r-1,c]==0:  # conosciamo bordo superiore
      b[i] = b[i] + img_matrix_L[r-1,c]
    else:
      unknown_c = ix[r-1,c]
      A[i,unknown_c] = -1
    if binary_mask[r+1,c]==0:  # conosciamo bordo inferiore
      b[i] = b[i] + img_matrix_L[r+1,c]
    else:
      unknown_c = ix[r+1,c]
      A[i,unknown_c] = -1
    if binary_mask[r,c-1]==0:  # conosciamo bordo sx
      b[i] = b[i] + img_matrix_L[r,c-1]
    else:
      unknown_c = ix[r,c-1]
      A[i,unknown_c] = -1
    if binary_mask[r,c+1]==0:  # conosciamo bordo dx
      b[i] = b[i] + img_matrix_L[r,c+1]
    else:
      unknown_c = ix[r,c+1]
      A[i,unknown_c] = -1
    i=i+1

x = spsolve(A.tocsr(),b)

norm = (x - x.min()) / (x.max() - x.min()) * 255
norm.astype(np.uint8)

norm.astype(np.uint8).reshape(98,-1)

rec = img_matrix_L.copy()
rec[1:-1,1:-1]=norm.astype(np.uint8).reshape(98,-1)
Image.fromarray(rec).show()

'''
import matplotlib.pyplot as plt

# 8. Visualizzazione
plt.figure(figsize=(12, 4))
plt.subplot(1, 3, 1)
plt.title("Original")
plt.imshow(img_matrix_L, cmap='gray')
plt.axis('off')

plt.subplot(1, 3, 2)
plt.title("Reconstructed")
plt.imshow(rec, cmap='gray')
plt.axis('off')

plt.subplot(1, 3, 3)
plt.title("Difference (abs)")
plt.imshow(np.abs(img_matrix_L - rec), cmap='hot')
plt.axis('off')

plt.tight_layout()
plt.show()
'''

"""## [ACTUAL]: Gradiente calcolato come differenze"""

# gradiente calcolato come differenze su immagine padded, stessa dimensione dell'input

img_matrix_L = np.asarray(img.convert('L'), copy=True)

padded = np.zeros((img_matrix_L.shape[0]+2,img_matrix_L.shape[1]+2))
padded[1:-1,1:-1] = img_matrix_L.copy()
padded[1:-1, 0] = padded[1:-1, 1]
padded[1:-1, -1] = padded[1:-1, -2]
padded[0, 1:-1] = padded[1, 1:-1]
padded[-1, 1:-1] = padded[-2, 1:-1]

Gx = np.zeros((img_matrix_L.shape[0], img_matrix_L.shape[1]))
Gy = np.zeros((img_matrix_L.shape[0], img_matrix_L.shape[1]))

for h in range(img_matrix_L.shape[0]):
    for w in range(img_matrix_L.shape[1]):
        Gx[h,w] = padded[h, w+1] - padded[h, w]
        Gy[h,w] = padded[h+1, w] - padded[h, w]

M = np.sqrt(Gx * Gx + Gy * Gy)
Image.fromarray(M.astype(np.uint8)).show()


N = len(binary_mask[binary_mask==1])
i = 0
A = lil_matrix((N,N))
b = np.zeros(N)

# r e c per scorrere sulla matrice immagine e sulla maschera
for r in range(0, img_matrix_L.shape[0]):
  for c in range(0, img_matrix_L.shape[1]):

    if binary_mask[r,c] == 0: continue  # non è un pixel da ricostruire

    A[i,i] = 4
    b[i] = Gx[r,c]-Gx[r,c+1] + Gy[r,c]-Gy[r+1,c]  # b[i] = Gx[r,c]-Gx[r,c-1] + Gy[r,c]-Gy[r-1,c] prev
    if binary_mask[r-1,c]==0:  # conosciamo bordo superiore
      b[i] = b[i] + img_matrix_L[r-1,c]
    else:
      unknown_c = ix[r-1,c]
      A[i,unknown_c] = -1
    if binary_mask[r+1,c]==0:  # conosciamo bordo inferiore
      b[i] = b[i] + img_matrix_L[r+1,c]
    else:
      unknown_c = ix[r+1,c]
      A[i,unknown_c] = -1
    if binary_mask[r,c-1]==0:  # conosciamo bordo sx
      b[i] = b[i] + img_matrix_L[r,c-1]
    else:
      unknown_c = ix[r,c-1]
      A[i,unknown_c] = -1
    if binary_mask[r,c+1]==0:  # conosciamo bordo dx
      b[i] = b[i] + img_matrix_L[r,c+1]
    else:
      unknown_c = ix[r,c+1]
      A[i,unknown_c] = -1
    i=i+1

x = spsolve(A.tocsr(),b)

norm = (x - x.min()) / (x.max() - x.min()) * 255
norm.astype(np.uint8)

rec = img_matrix_L.copy()
rec[1:-1,1:-1]=norm.reshape(98,-1)
Image.fromarray(rec.astype(np.uint8)).show()

'''
import matplotlib.pyplot as plt

# 8. Visualizzazione
plt.figure(figsize=(12, 4))
plt.subplot(1, 3, 1)
plt.title("Original")
plt.imshow(img_matrix_L, cmap='gray')
plt.axis('off')

plt.subplot(1, 3, 2)
plt.title("Reconstructed")
plt.imshow(rec, cmap='gray')
plt.axis('off')

plt.subplot(1, 3, 3)
plt.title("Difference (abs)")
plt.imshow(np.abs(img_matrix_L - rec), cmap='hot')
plt.axis('off')

plt.tight_layout()
plt.show()
'''

"""# COLORS"""

img_matrix = np.asarray(img, copy=True).astype(np.uint8)
print(img_matrix.shape)

binary_mask = np.ones((img_matrix.shape[0],img_matrix.shape[1]), dtype=bool)
binary_mask[0,:] = 0
binary_mask[:,0] = 0
binary_mask[-1,:] = 0
binary_mask[:,-1] = 0

# indice dei pixel da ricostruire:

ix = -np.ones((img_matrix.shape[0],img_matrix.shape[1]), dtype=int)
i = 0

for r in range(img_matrix.shape[0]):
  for c in range(img_matrix.shape[1]):
      if binary_mask[r,c]:
        ix[r,c] = i
        i=i+1

# per ogni channel, gradiente calcolato su immagine padded, stessa dimensione dell'input

padded = np.zeros((img_matrix.shape[0]+2,img_matrix.shape[1]+2, 3))
padded[1:-1,1:-1, :] = img_matrix.copy()
padded[1:-1, 0] = padded[1:-1, 1]
padded[1:-1, -1] = padded[1:-1, -2]
padded[0, 1:-1] = padded[1, 1:-1]
padded[-1, 1:-1] = padded[-2, 1:-1]

Gx = np.zeros((img_matrix.shape[0], img_matrix.shape[1], 3))
Gy = np.zeros((img_matrix.shape[0], img_matrix.shape[1], 3))

for c in range(3):
  for h in range(img_matrix.shape[0]):
      for w in range(img_matrix.shape[1]):
          Gx[h,w,c] = padded[h+1, w+1, c] - padded[h+1, w, c]
          Gy[h,w,c] = padded[h+1, w+1, c] - padded[h, w+1, c]

M = np.sqrt(Gx * Gx + Gy * Gy)
Image.fromarray(M.astype(np.uint8)).show()

N = len(binary_mask[binary_mask==1])
reconstruct = img_matrix.copy()

for ch in range(3):
  i = 0
  A = lil_matrix((N,N))
  b = np.zeros(N)

  # r e c per scorrere sulla matrice immagine e sulla maschera
  for r in range(0, img_matrix.shape[0]):
    for c in range(0, img_matrix.shape[1]):

      if binary_mask[r,c] == 0: continue  # non è un pixel da ricostruire

      A[i,i] = 4
      b[i] = Gx[r,c, ch]-Gx[r,c+1, ch] + Gy[r,c, ch]-Gy[r+1,c, ch]
      if binary_mask[r-1,c]==0:  # conosciamo bordo superiore
        b[i] = b[i] + img_matrix[r-1,c, ch]
      else:
        unknown_c = ix[r-1,c]
        A[i,unknown_c] = -1
      if binary_mask[r+1,c]==0:  # conosciamo bordo inferiore
        b[i] = b[i] + img_matrix[r+1,c, ch]
      else:
        unknown_c = ix[r+1,c]
        A[i,unknown_c] = -1
      if binary_mask[r,c-1]==0:  # conosciamo bordo sx
        b[i] = b[i] + img_matrix[r,c-1, ch]
      else:
        unknown_c = ix[r,c-1]
        A[i,unknown_c] = -1
      if binary_mask[r,c+1]==0:  # conosciamo bordo dx
        b[i] = b[i] + img_matrix[r,c+1, ch]
      else:
        unknown_c = ix[r,c+1]
        A[i,unknown_c] = -1
      i=i+1
  print("b: " + str(b))
  x = spsolve(A.tocsr(),b)
  print("x: " + str(x))
  norm = (x - x.min()) / (x.max() - x.min()) * 255
  print("norm: " + str(norm.astype(np.uint8)))
  reconstruct[1:-1,1:-1,ch]=norm.reshape(98,-1)

Image.fromarray(reconstruct).show()
