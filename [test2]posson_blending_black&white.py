# -*- coding: utf-8 -*-
"""PoissonBlending.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1VG3MwpkVVMcZSXhpV4eWlr0gl3XbIB10

https://github.com/PPPW/poisson-image-editing/blob/master/main.py

https://cs.brown.edu/courses/cs129/asgn/proj3_poisson/index.html

https://erkaman.github.io/posts/poisson_blending.html

https://github.com/Erkaman/poisson_blend/blob/master/src/main.cpp
"""

import numpy as np
from PIL import Image
from scipy.sparse import lil_matrix
from scipy.sparse.linalg import spsolve

def simple_paste(src_matrix, tgt_matrix, bin_mask):
    """Source image and target image should have the same dimensions."""
    out = tgt_matrix.copy()

    for row in range(src_matrix.shape[0]):
      for col in range(src_matrix.shape[1]):
        if bin_mask[row,col]:
          out[row,col] = src_matrix[row,col]
    return out


# enable if you want to show the source and target gradients combined
show_grad = False


#source = Image.open('imgs/kitten.png')
source = Image.open('imgs/balloon.png')
#source = Image.open('imgs/penguin.png')

#target = Image.open('imgs/library.png')
target = Image.open('imgs/colosseum.png')

#mask = Image.open('imgs/kitten_mask.png')
mask = Image.open('imgs/balloon_mask.png')
#source = Image.open('imgs/penguin_mask.png')

mask_matrix = np.asarray(mask, copy=True)

# mask has multiple channels, but the binary_mask is contained in only one (might change based on how the mask is created):

s = 0
for i in range(mask_matrix.shape[2]):
  if len(np.unique(mask_matrix[:,:,i])) > 1:  # only one channel has more than 1 value, if the mask is created correctly
    s = i
    break

mask_matrix = mask_matrix[:,:,s]



img_matrix_L = np.asarray(source.convert('L'), copy=True)
target_matrix = np.asarray(target.convert('L'), copy=True)

# get a masked version of the source image
source_masked = img_matrix_L.copy()
for r in range(source_masked.shape[0]):
  for c in range(source_masked.shape[1]):
    if not mask_matrix[r,c]:
      source_masked[r,c] = 0

# creation of a mask for the target image to state where to place the source image

print("Target dimensions:" + str(target_matrix.shape))
print("Source dimensions" + str(source_masked.shape))

# top-left coordinates from where to place the source image
# for kitten and penguin in the library
#x0 = 330
#y0 = 250

# for balloons above colosseum
x0 = 200
y0 = 200

# the images are brought to have the same shape in order to place the source image precisely and rapidly
source_extended = np.zeros((target_matrix.shape[0], target_matrix.shape[1]))
source_extended[x0 : x0 + source_masked.shape[0], y0 : y0 + source_masked.shape[1]] = source_masked
Image.fromarray(source_extended.astype(np.uint8))

binary_mask = source_extended.copy().astype(np.bool)

# simple paste for example
Image.fromarray(simple_paste(source_extended, target_matrix, binary_mask)).show()

# the gradient will be computed considering the whole source image, not only the masked part
source_extended[x0 : x0 + source_masked.shape[0], y0 : y0 + source_masked.shape[1]] = img_matrix_L

# index of the pixels to be reconstructed:

ix = -np.ones((target_matrix.shape[0],target_matrix.shape[1]), dtype=int)  # same dimensions of the target image
i = 0

for r in range(target_matrix.shape[0]):
  for c in range(target_matrix.shape[1]):
      if binary_mask[r,c]==1:
        ix[r,c] = i
        i=i+1
print("Pixels to be reconstructed: " + str(i))

N = i

# grad source image
padded = np.zeros((source_extended.shape[0]+2,source_extended.shape[1]+2))
padded[1:-1,1:-1] = source_extended.copy()
padded[1:-1, 0] = padded[1:-1, 1]
padded[1:-1, -1] = padded[1:-1, -2]
padded[0, 1:-1] = padded[1, 1:-1]
padded[-1, 1:-1] = padded[-2, 1:-1]

Gx_source = np.zeros((source_extended.shape[0], source_extended.shape[1]))
Gy_source = np.zeros((source_extended.shape[0], source_extended.shape[1]))

for h in range(source_extended.shape[0]):
    for w in range(source_extended.shape[1]):
        if binary_mask[h,w]:  # compute only gradients of pixels in the mask
            Gx_source[h,w] = padded[h+1, w+1] - padded[h+1, w]
            Gy_source[h,w] = padded[h+1, w+1] - padded[h, w+1]

# [for visualization]
#M = np.sqrt(Gx_source * Gx_source + Gy_source * Gy_source)
#Image.fromarray(M.astype(np.uint8)).show()

if show_grad:
    # [NOT NECESSARY; FOR VISUALIZATION] grad target image:

    padded = np.zeros((target_matrix.shape[0]+2,target_matrix.shape[1]+2))
    # to keep dimensions from img matrix and its grad matrix --> padding by replicating border pixels
    padded[1:-1, 1:-1] = target_matrix.copy()
    padded[1:-1, 0] = padded[1:-1, 1]
    padded[1:-1, -1] = padded[1:-1, -2]
    padded[0, 1:-1] = padded[1, 1:-1]
    padded[-1, 1:-1] = padded[-2, 1:-1]

    Gx_target = np.zeros((target_matrix.shape[0], target_matrix.shape[1]))
    Gy_target = np.zeros((target_matrix.shape[0], target_matrix.shape[1]))

    for h in range(target_matrix.shape[0]):
        for w in range(target_matrix.shape[1]):
            # padded [h+1,w+1] corresponds to target [h,w]
            Gx_target[h,w] = padded[h+1, w+1] - padded[h+1, w]
            Gy_target[h,w] = padded[h+1, w+1] - padded[h, w+1]

    # [for visualization]
    #M = np.sqrt(Gx_target * Gx_target + Gy_target * Gy_target)
    #Image.fromarray(M.astype(np.uint8)).show()

    # replace target grads in the masked area with source grads, for visualization

    grad_insertion_x = Gx_target.copy()
    grad_insertion_y = Gy_target.copy()

    for r in range(binary_mask.shape[0]):
      for c in range(binary_mask.shape[1]):
        if binary_mask[r,c]:
          grad_insertion_x[r,c] = Gx_source[r,c]
          grad_insertion_x[r,c+1] = Gx_source[r,c+1]
          grad_insertion_y[r,c] = Gy_source[r,c]
          grad_insertion_y[r+1,c] = Gy_source[r+1,c]

    # [for visualization]
    M = np.sqrt(grad_insertion_x * grad_insertion_x + grad_insertion_y * grad_insertion_y)
    Image.fromarray(M.astype(np.uint8)).show()

i = 0
A = lil_matrix((N,N))
b = np.zeros(N)

for r in range(target_matrix.shape[0]):
  for c in range(target_matrix.shape[1]):

    if binary_mask[r,c] == 0: continue  # not to be reconstructed

    A[i,i] = 4
    b[i] = Gx_source[r,c]-Gx_source[r,c+1] + Gy_source[r,c]-Gy_source[r+1,c]
    # same thing but directly, no need for gradients explicit computation
    #b[i] = 4*source_extended[r,c] - source_extended[r-1,c] - source_extended[r+1,c] - source_extended[r,c+1] - source_extended[r,c-1]

    if binary_mask[r-1,c]==0:  # top pixel known
      b[i] = b[i] + target_matrix[r-1,c]
    else:
      unknown_c = ix[r-1,c]
      A[i,unknown_c] = -1
    if binary_mask[r+1,c]==0:  # bottom pixel known
      b[i] = b[i] + target_matrix[r+1,c]
    else:
      unknown_c = ix[r+1,c]
      A[i,unknown_c] = -1
    if binary_mask[r,c-1]==0:  # left pixel known
      b[i] = b[i] + target_matrix[r,c-1]
    else:
      unknown_c = ix[r,c-1]
      A[i,unknown_c] = -1
    if binary_mask[r,c+1]==0:  # right pixel known
      b[i] = b[i] + target_matrix[r,c+1]
    else:
      unknown_c = ix[r,c+1]
      A[i,unknown_c] = -1
    i=i+1

print("b: " + str(b))
x = spsolve(A.tocsr(),b)
print("x: " + str(x))
x = np.clip(x, 0, 255)

x = np.clip(x, 0, 255)

output = target_matrix.copy().astype(int)
for r in range(ix.shape[0]):
  for c in range(ix.shape[1]):
    if ix[r,c] != -1:
      output[r,c] = x[ix[r,c]]

#norm = (output - output.min()) / (output.max() - output.min()) * 255  # normalization inefficient, clipping values works
Image.fromarray(output.astype(np.uint8)).show()